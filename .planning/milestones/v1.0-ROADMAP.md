# Milestone v1.0: MVP

**Status:** ✅ SHIPPED 2026-02-24
**Phases:** 1-12
**Total Plans:** 12 (one per phase — built without formal plan/task decomposition)

## Overview

GongIntel MVP — a web application that authenticates users via Google SSO (@cast.ai only), connects to a Google Drive folder containing Gong call transcripts, uses Claude to analyze calls across 8 dimensions, stores results in Firestore, and presents a React dashboard with export capability.

## Phases

### Phase 1: Project Scaffolding

**Goal**: Set up Bun monorepo with workspaces, TypeScript config, and .gitignore
**Depends on**: None

**Details:**
Created root `package.json` with Bun workspaces (`apps/api`, `apps/web`), shared `tsconfig.json` with strict mode, `bunfig.toml`, and `.gitignore` excluding node_modules, dist, .env, and sample transcripts.

### Phase 2: Domain Types & Config

**Goal**: Define shared TypeScript types and environment configuration
**Depends on**: Phase 1

**Details:**
Created domain types (`ParsedTranscript`, `UserDoc`, `CallDoc`, `AnalysisDoc`, etc.) in `apps/api/src/lib/types.ts`. Typed environment access via lazy getters in `env.ts`. Hono context type definitions in `hono-types.ts`. Frontend type mirrors in `apps/web/src/lib/types.ts`.

### Phase 3: Google OAuth SSO

**Goal**: Implement Google OAuth 2.0 login flow with @cast.ai domain restriction
**Depends on**: Phase 2

**Details:**
Login redirect to Google consent screen, callback handler exchanging code for tokens, user info retrieval, domain validation, JWT session creation (HS256, 7-day expiry), cookie management (httpOnly, secure in prod, SameSite Lax). Auth middleware validates JWT from cookie and sets user context. Logout clears cookie.

### Phase 4: Google Drive Integration

**Goal**: Read transcript files from shared Google Drive folder via service account
**Depends on**: Phase 2

**Details:**
Service account authentication using `GOOGLE_SERVICE_ACCOUNT_KEY` JSON. File listing with pagination against configured folder ID. File content reading (text/plain). File metadata retrieval. All methods later wrapped with retry logic in Phase 12.

### Phase 5: Transcript Parser

**Goal**: Parse Gong transcript format into structured data
**Depends on**: Phase 2

**Details:**
Handles header block (Call ID, Date, Title, Participants with name + email). Parses speaker turns with numeric IDs, `[MM:SS]` timestamps, text content, and optional `[Topic]` tags. Extracts filename-encoded date and Gong ID. SHA-256 hash generation for change detection. `formatTranscriptForAnalysis()` helper for Claude prompt.

### Phase 6: Participant Matcher

**Goal**: Match authenticated users to call participants for access control
**Depends on**: Phase 2

**Details:**
Case-insensitive, whitespace-trimmed email comparison. `isUserParticipant()` checks if user email appears in call participant list. Used in all protected routes to enforce per-call access control.

### Phase 7: Claude Analysis Pipeline

**Goal**: Analyze transcripts with Claude across 8 dimensions
**Depends on**: Phases 5, 6

**Details:**
Constructs detailed analysis prompt with participant list, speaker IDs, and full transcript text. Requests JSON response with exact schema. Parses response (handles markdown code fences). Validates required fields (speakerMap, summary, sentimentOverall). Defaults missing arrays. Model: claude-sonnet-4-20250514 with max_tokens 8000, temperature 0.2. Retry and timeout added in Phase 12.

### Phase 8: Firestore Persistence

**Goal**: CRUD operations for users, calls, and analyses in Firestore
**Depends on**: Phase 2

**Details:**
Firebase Admin SDK initialization with service account credentials. Collections: `users`, `calls`, `analyses`. Operations: upsert/get user, upsert/get/query calls (by ID, Drive file ID, user email), create/update/get analyses (with versioning, count queries). All operations later wrapped with error handling in Phase 12.

### Phase 9: API Routes

**Goal**: HTTP endpoints for calls, analysis, and export
**Depends on**: Phases 3-8

**Details:**
- `GET /api/calls` — Lists Drive files, syncs to Firestore, filters by user participation, includes analysis preview
- `GET /api/calls/:id` — Call detail with participant check
- `POST /api/calls/:callId/analyze` — Triggers background analysis, returns analysis ID immediately
- `GET /api/calls/:callId/analysis` — Latest completed analysis
- `GET /api/calls/:callId/analysis/status` — Polling endpoint
- `GET /api/calls/:callId/export?format=md` — Full markdown report generation
- `GET /auth/login`, `GET /auth/callback`, `GET /auth/logout`, `GET /auth/me`

### Phase 10: React Frontend

**Goal**: Interactive dashboard for viewing calls and analysis results
**Depends on**: Phase 9

**Details:**
- **Login page** — Google SSO button with @cast.ai note
- **Dashboard** — Call list with sentiment badges and topic preview, loading/error states, logout
- **CallDetail** — Full analysis display: summary, sentiment (overall + chart), talk ratio, topics, objections with handling scores, action items, competitor mentions, metadata. Analyze button with polling. Export button.
- **Components** (10): CallList, SentimentChart, ObjectionCard, ActionItems, TalkRatio, TopicBadges, AnalyzeButton, ExportButton, plus ErrorBoundary added in Phase 12
- **API client** — Typed fetch wrapper with credential handling and error class

### Phase 11: Deployment Infrastructure

**Goal**: Production deployment configuration for Google Cloud
**Depends on**: Phases 9, 10

**Details:**
Multi-stage Dockerfile: Bun base image, dependency install, build step, production runtime. Deploy script (`scripts/deploy.sh`): builds and pushes container to Cloud Run, deploys web static files to Cloud Storage with CDN.

### Phase 12: Error Handling & Resilience

**Goal**: Comprehensive error handling, structured logging, and resilience patterns
**Depends on**: Phases 1-11

**Details:**
- **Custom error types** (`errors.ts`): `AppError` base class with statusCode/code/isOperational. Subclasses: `NotFoundError`, `AuthError`, `ValidationError`, `ExternalServiceError`.
- **Structured logger** (`logger.ts`): JSON output, log levels (debug/info/warn/error), error serialization with stack traces, Cloud Run compatible.
- **Global handlers** (`index.ts`): `app.onError()` catches all route errors with request ID correlation, `app.notFound()` returns JSON 404, `process.on('uncaughtException'/'unhandledRejection')` for last-resort logging.
- **Startup validation** (`env.ts`): Eagerly validates all required env vars and JSON parseability of service account key before server starts.
- **Service retries**: Google Drive (3 retries, exponential backoff on 429/5xx/network errors), Claude (3 retries, respects Retry-After header, handles 429/529/5xx), guarded JSON.parse in both Drive and Firestore services.
- **Firestore wrapping**: All 11+ operations wrapped in `withFirestore()` error handler.
- **Auth logging**: JWT failures logged with specific reason (expired, malformed, invalid signature, claim validation).
- **Analysis resilience**: `.catch()` on fire-and-forget background call, 3-minute job timeout, structured logging of all analysis lifecycle events.
- **Route improvements**: All routes use typed errors (NotFoundError, AuthError) caught by global handler. All console.log/error replaced with structured logger.
- **React ErrorBoundary**: Catches render crashes, shows recovery UI with "Return to Dashboard" button.
- **Frontend fixes**: Login.tsx reads/displays `?error=` param, CallDetail.tsx shows error state for non-401 failures, polling capped at 90 iterations with cleanup on error/unmount, api.ts parses JSON error bodies.
- **Global JS handler**: `window.onunhandledrejection` in main.tsx prevents silent promise failures.

---

## Milestone Summary

**Decimal Phases:** None (linear build, no inserted phases)

**Key Decisions:**
- Decision: Bun monorepo over Next.js (Rationale: Simpler deployment model, separate scaling)
- Decision: Hono over Express (Rationale: Lighter, better TS support)
- Decision: Service account for Drive (Rationale: Admin access, no per-user OAuth complexity)
- Decision: Firestore over PostgreSQL (Rationale: Schemaless fits evolving analysis shape)
- Decision: Fire-and-forget analysis with polling (Rationale: Non-blocking UX)
- Decision: Custom AppError hierarchy (Rationale: Consistent HTTP status mapping, operational vs programmer errors)
- Decision: JSON structured logging (Rationale: Cloud Run auto-capture)

**Issues Resolved:**
- Transcript speaker IDs are opaque numbers — resolved by delegating mapping to Claude via conversational cue analysis
- Firestore array-contains doesn't work on object arrays — resolved with in-memory filtering (acceptable at scale)
- JWT failures were silently swallowed — resolved with jose error type inspection and structured logging

**Issues Deferred:**
- PDF export (returns markdown for both md and pdf formats)
- Automated testing (zero tests)
- Call list pagination/caching (full Drive re-list each request)
- JWT refresh mechanism (7-day hard expiry)
- Rate limiting
- Live GCP deployment validation

**Technical Debt Incurred:**
- No automated tests (unit, integration, or e2e)
- In-memory participant filtering won't scale beyond ~1000 calls
- No incremental sync for Drive files (full re-list every request)
- Deployment infra untested against real GCP project

---

_For current project status, see .planning/ROADMAP.md_
